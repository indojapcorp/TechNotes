<noscript> 
  <style>
    body {
      -ms-overflow-style: scrollbar;
      overflow-y: scroll;
      overscroll-behavior-y: none;
    }

    .errorContainer {
      background-color: #FFF;
      color: #0F1419;
      max-width: 600px;
      margin: 0 auto;
      padding: 10%;
      font-family: Helvetica, sans-serif;
      font-size: 16px;
    }

    .errorButton {
      margin: 3em 0;
    }

    .errorButton a {
      background: #1DA1F2;
      border-radius: 2.5em;
      color: white;
      padding: 1em 2em;
      text-decoration: none;
    }

    .errorButton a:hover,
    .errorButton a:focus {
      background: rgb(26, 145, 218);
    }

    .errorFooter {
      color: #657786;
      font-size: 80%;
      line-height: 1.5;
      padding: 1em 0;
    }

    .errorFooter a,
    .errorFooter a:visited {
      color: #657786;
      text-decoration: none;
      padding-right: 1em;
    }

    .errorFooter a:hover,
    .errorFooter a:active {
      text-decoration: underline;
    }

      #placeholder,
      #react-root {
        display: none !important;
      }
      body {
        background-color: #FFF !important;
      }
    </style> 
  <div class="errorContainer"> 
   <img width="46" height="38" srcset="https://abs.twimg.com/errors/logo46x38.png 1x, https://abs.twimg.com/errors/logo46x38@2x.png 2x" src="https://abs.twimg.com/errors/logo46x38.png" alt="Twitter"> 
   <h1>JavaScript is not available.</h1> 
   <p>We’ve detected that JavaScript is disabled in this browser. Please enable JavaScript or switch to a supported browser to continue using twitter.com. You can see a list of supported browsers in our Help Center.</p> 
   <p class="errorButton"><a href="https://help.twitter.com/using-twitter/twitter-supported-browsers">Help Center</a></p> 
   <p class="errorFooter"> <a href="https://twitter.com/tos">Terms of Service</a> <a href="https://twitter.com/privacy">Privacy Policy</a> <a href="https://support.twitter.com/articles/20170514">Cookie Policy</a> <a href="https://legal.twitter.com/imprint.html">Imprint</a> <a href="https://business.twitter.com/en/help/troubleshooting/how-twitter-ads-work.html?ref=web-twc-ao-gbl-adsinfo&amp;utm_source=twc&amp;utm_medium=web&amp;utm_campaign=ao&amp;utm_content=adsinfo">Ads info</a> © 2022 Twitter, Inc. </p> 
  </div> 
 </noscript>
<h2>NumPY Interview Questions for Freshers</h2>

<h3>1. What is NumPy? Why should we use it?</h3>

<p>NumPy (also called Numerical Python) is a highly flexible, optimized, open-source package meant for array processing. It provides tools for delivering high-end performance while dealing with N-dimensional powerful array objects. It is also beneficial for performing scientific computations, mathematical, and logical operations, sorting operations, I/O functions, basic statistical and linear algebra-based operations along with random simulation and broadcasting functionalities. Due to the vast range of capabilities, NumPy has become very popular and is the most preferred package. The following image represents the uses of NumPy.</p>

<h3>2. Why is NumPy preferred over Matlab, Octave, Idl or Yorick?</h3>

<p>NumPy is an open-source, high-performing library that allows complex mathematical and scientific computational capabilities. It makes use of Python language which is a high-level, easy-to-learn, general-purpose programming language. It supports the following:</p>

<ul>
	<li>Powerful functions for performing complex mathematical operations on multi-dimensional matrices and arrays. The operations on ndarrays of NumPy are approximately up to 50% faster when compared to operations on native lists using loops. This efficiency is very much useful when the arrays have millions of elements.</li>
	<li>Provides indexing syntax to access portions of data easily in a large array.</li>
	<li>Provides built-in functions which help to easily perform operations related to linear algebra and statistics.</li>
	<li>It takes only a few lines of code to achieve complex computations using NumPy.</li>
</ul>

<h3>3. How are NumPy arrays better than Python&rsquo;s lists?</h3>

<ul>
	<li>Python lists support storing heterogeneous data types whereas NumPy arrays can store datatypes of one nature itself. NumPy provides extra functional capabilities that make operating on its arrays easier which makes NumPy array advantageous in comparison to Python lists as those functions cannot be operated on heterogeneous data.</li>
	<li>NumPy arrays are treated as objects which results in minimal memory usage. Since Python keeps track of objects by creating or deleting them based on the requirements, NumPy objects are also treated the same way. This results in lesser memory wastage.</li>
	<li>NumPy arrays support multi-dimensional arrays.</li>
	<li>NumPy provides various powerful and efficient functions for complex computations on the arrays.</li>
	<li>NumPy also provides various range of functions for BitWise Operations, String Operations, Linear Algebraic operations, Arithmetic operations etc. These are not provided on Python&rsquo;s default lists.</li>
</ul>

<h3>&nbsp;</h3>

<hr />
<p>&nbsp;</p>

<h3>4. What are ndarrays in NumPy?</h3>

<p>ndarray object is the core of the NumPy package. It consists of n-dimensional arrays storing elements of the same data types and also has many operations that are done in compiled code for optimised performance. These arrays have fixed sizes defined at the time of creation. Following are some of the properties of ndarrays:</p>

<ul>
	<li>When the size of ndarrays is changed, it results in a new array and the original array is deleted.</li>
	<li>The ndarrays are bound to store homogeneous data.</li>
	<li>They provide functions to perform advanced mathematical operations in an efficient manner.</li>
</ul>

<h3>6. How do you find the data type of the elements stored in the NumPy arrays?</h3>

<p>NumPy supports the following datatypes:</p>

<ul>
	<li>i - integer</li>
	<li>S - string</li>
	<li>b - boolean</li>
	<li>f - float</li>
	<li>u - unsigned integer</li>
	<li>c - complex float</li>
	<li>m - timedelta</li>
	<li>M - datetime</li>
	<li>O - object</li>
	<li>U - unicode string</li>
	<li>V - fixed memory chunk for types such as void<br />
	We can make use of the dtype property that returns the type of the elements stored in the NumPy array. Let us consider the below code snippet. We create some sample arrays and we see what the data types of these arrays are.</li>
</ul>

<p>array.dtype</p>

<p>Explain the data types supported by&nbsp; NumPy.</p>

<ul>
	<li><strong>numpy.bool_</strong>&nbsp;: bool</li>
	<li><strong>numpy.byte</strong>&nbsp;: signed char</li>
	<li><strong>numpy.ubyte</strong>&nbsp;: unsigned char</li>
	<li><strong>numpy.short&nbsp;</strong>: short</li>
	<li><strong>numpy.ushort</strong>&nbsp;: unsigned short</li>
	<li><strong>numpy.intc&nbsp;:</strong>&nbsp;int</li>
	<li><strong>numpy.uintc&nbsp;</strong>: unsigned int</li>
	<li><strong>numpy.int_</strong>&nbsp;: long</li>
	<li><strong>numpy.uint&nbsp;:</strong>&nbsp;unsigned long</li>
	<li><strong>numpy.longlong</strong>&nbsp;:&nbsp; long&nbsp;long</li>
	<li><strong>numpy.ulonglong</strong>&nbsp;: unsigned long&nbsp;long</li>
	<li><strong>numpy.half&nbsp;/ numpy.float16</strong>&nbsp;: Half precision float</li>
	<li><strong>numpy.single</strong>&nbsp;: float</li>
	<li><strong>numpy.double&nbsp;</strong>: double</li>
	<li><strong>numpy.longdouble</strong>&nbsp;: long double</li>
	<li><strong>numpy.csingle</strong>&nbsp;: float complex</li>
	<li><strong>numpy.cdouble</strong>&nbsp;: double complex</li>
	<li><strong>numpy.clongdouble</strong>&nbsp;: long double complex</li>
</ul>

<h3>7. How can you reverse a NumPy array?</h3>

<p>There are two ways of reversing a NumPy array.</p>

<ul>
	<li><strong>Method 1:</strong>&nbsp;Using the slicing method: We can make use of [::-1] for reversing the array. The following example demonstrates this:</li>
	<li>arr[::-1]</li>
</ul>

<p>&nbsp;</p>

<ul>
	<li><strong>Method 2:</strong>&nbsp;flipud function: This function is provided by NumPy to reverse the NumPy array. Let us see the below example about its usage.</li>
	<li>np.flipud(arr)</li>
</ul>

<h3>8. How is np.mean() different from np.average() in NumPy?</h3>

<ul>
	<li>np.mean() method calculates the arithmetic mean and provides additional options for input and results. For example, it has the option to specify what data types have to be taken, where the result has to be placed etc.</li>
	<li>np.average() computes the weighted average if the weights parameter is specified. In the case of weighted average, instead of considering that each data point is contributing equally to the final average, it considers that some data points have more weightage than the others (unequal contribution).</li>
</ul>

<h3>9. How do you count the frequency of a given positive value appearing in the NumPy array?</h3>

<p>We can make use of the bincount() function to compute the number of times a given value is there in the array. This function accepts only positive integers and boolean expressions as the arguments.</p>

<p>arr=np.array([1,2,1,3,3])</p>

<p>result=np.bincount(arr)</p>

<p>The result is:</p>

<p>[2,1,2]</p>

<p>It has to be noted here that each element represents the count of the corresponding index value present in the original array. This is demonstrated in the below image:</p>

<h3>10. How do we check for an empty array (or zero elements array)?</h3>

<p>We can check for the emptiness of a NumPy array by making use of the size attribute.<br />
Let us consider the below example. We have NumPy array arr filled with zeros. If the size element returns zero, that means the array is empty or it only consists of zeros.</p>

<p>arr=np.zeros((1,0))</p>

<p>print(arr.size)</p>

<p>This return 0</p>

<h3>11. How is arr[:,0] different from arr[:,[0]]</h3>

<p><code>arr[:,0]</code>&nbsp;- Returns 0th index elements of all rows. In other words, return the first column elements.</p>

<p><code>arr[:,[0]]</code>&nbsp;- This returns the elements of the first column by adding extra dimension to it.</p>

<h3>12. How do you multiply 2 NumPy array matrices?</h3>

<p>We can make use of the dot() for multiplying matrices represented as NumPy arrays. This is represented in the code snippet below:</p>

<p>A=np.arange(15,24).reshape(3,3)</p>

<p>B=np.arange(20,29).reshape(3,3)</p>

<p>result=A.dot(B)</p>

<p>Output</p>

<p>[[1110,1158,1206]</p>

<p>[1317 1374 1431]</p>

<p>[1524 1590 1656]]</p>

<h3>13. How do you concatenate 2 NumPy arrays?</h3>

<p>Concatenating 2 arrays by adding elements to the end can be achieved by making use of the concatenate() method of the NumPy package. Syntax:</p>

<p>np.concatenate((a1,a2, ...), axis=0 , out=None)</p>

<p>where,</p>

<ul>
	<li>a1,a2: arrays of the same shape</li>
	<li>axis: Represents the axis along which the arrays are joined. The default value is 0.</li>
	<li>out: If mentioned, it specifies the destination for placing the result.</li>
</ul>

<h3>14. How do you convert Pandas DataFrame to a NumPy array?</h3>

<p>The to_numpy() method of the NumPy package can be used to convert Pandas DataFrame, Index and Series objects.</p>

<p>Consider we have a DataFrame df, we can either convert the whole Pandas DataFrame df to NumPy array or even select a subset of Pandas DataFrame to NumPy array by using the to_numpy() method as shown in the example below:</p>

<h2>NumPY Interview Questions for Experienced</h2>

<h3>15. What do you understand by Vectorization in NumPy?</h3>

<p>Function Vectorization technically means that the function is applied to all elements in the array. Typically, certain python functionalities on arrays (such as loops) are slower in nature because python arrays can contain elements of different data types. Since the C program expects a specific datatype, there are chances of compiler optimisation which makes C code run faster. Since NumPy arrays support storing elements of a single datatype, most of the implementations of the functions written in NumPy meant for arithmetic, logical operations etc have optimised C program code under their hood. Additionally, NumPy also helps developers create their own vectorised functions by following the below steps:</p>

<ul>
	<li>Write your required function that takes array elements as parameters.</li>
	<li>Vectorize the function by making use of the vectorize() method of the NumPy package.</li>
	<li>Give array inputs to the vectorized function.</li>
</ul>

<p>The below example demonstrates the process of vectorization.</p>

<h3>16. How is vstack() different from hstack() in NumPy?</h3>

<p>Both methods are used for combining the NumPy arrays. The main difference is that the hstack method combines arrays horizontally whereas the vstack method combines arrays vertically.<br />
For example, consider the below code.</p>

<h3>17. How do you find the local peaks (or maxima) in a 1-D NumPy Array?</h3>

<p>Peaks are the points that are surrounded by smaller value points on either side as shown in the image below:</p>

<p>There are two ways of finding local maxima:</p>

<p><strong>Using .where() method:</strong>&nbsp;This method lists all positions/indices where the element value at position i is greater than the element on either side of it. This method does not check for the points that have only one neighbour. This is demonstrated in the example below:</p>

<p>The&nbsp;<code>+1</code>&nbsp;at the end of the expression is required as it finds the indexes within the slice&nbsp;<code>arr[1:-1]</code>&nbsp;and not the entire array arr.</p>

<ul>
	<li>The where() method returns a tuple of arrays where the first element is our required array. Hence we add&nbsp;<code>[0]</code>&nbsp;after the where method.</li>
</ul>

<p><strong>Using combination of .diff(), .sign() and .where() method:</strong></p>

<ul>
	<li>In this method, we calculate the difference between each element using the diff() method of NumPy.</li>
	<li>Then we use the sign() method on the array to get the sign of difference.</li>
	<li>The value can be either -1 or +1. This result is then passed on to another diff() method which returns 0, -2 or +2 value. The value 0 indicates that the points are continuously increasing or decreasing, +2 indicates minimum peak and -2 indicates maximum peak (local maxima).</li>
	<li>We then identify the position or indexes of the local maxima using the where() method. The reason for using +1 at the end of where and [0] after where is the same as the explanation described in Method 1 for finding local maxima.</li>
</ul>

<p>18. How is Vectorization related to Broadcasting in NumPy?</p>

<p>Vectorization involves delegating NumPy operations internally to optimized C language functions to result in faster Python code. Whereas Broadcasting refers to the methods that allow NumPy to perform array-related arithmetic operations. The size or shape of the arrays does not matter in this case. Broadcasting solves the problem of mismatched shaped arrays by replicating the smaller array along the larger array to ensure both arrays are having compatible shapes for NumPy operations. Performing Broadcasting before Vectorization helps to vectorize operations which support arrays of different dimensions.</p>

<h3>19. What happens when the split() method is used for splitting NumPy arrays?</h3>

<p>1. np.split() : Equally splits arrays into multiple sub-arrays. It raises Value Error when the split cannot be equal.</p>

<ul>
	<li>Syntax:</li>
</ul>

<p>np.split(array,sections,axis=0)</p>

<p>where,</p>

<ul>
	<li>array - array that needs to be split</li>
	<li>sections -
	<ul>
		<li>If we give an integer X, X equal sub-arrays are obtained after dividing the array. If the split is not possible, ValueError is raised.
		<ul>
			<li>For example:</li>
		</ul>
		</li>
	</ul>
	</li>
</ul>

<h2>1) What is Numpy?</h2>

<p>Ans: NumPy is a general-purpose array-processing package. It provides a high-performance multidimensional array object, and tools for working with these arrays. It is the fundamental package for scientific computing with Python. &hellip; A powerful N-dimensional array object. Sophisticated (broadcasting) functions.</p>

<h2>2) Why NumPy is used in Python?</h2>

<p>Ans: NumPy is a package in Python used for Scientific Computing. NumPy package is used to perform different operations. The ndarray (NumPy Array) is a multidimensional array used to store values of same datatype. These arrays are indexed just like Sequences, starts with zero.</p>

<h2>3) What does NumPy mean in Python?</h2>

<p>Ans: NumPy (pronounced /ˈnʌmpaɪ/ (NUM-py) or sometimes /ˈnʌmpi/ (NUM-pee)) is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays.</p>

<h2>4) Where is NumPy used?</h2>

<p>Ans: NumPy is an open source numerical Python library. NumPy contains a multi-dimentional array and matrix data structures. It can be utilised to perform a number of mathematical operations on arrays such as trigonometric, statistical and algebraic routines. NumPy is an extension of Numeric and Numarray.</p>

<h2>5) How to Install Numpy in Windows?</h2>

<p>Ans: Step 1: Download Python for Windows 10/8/7. First, download the Python executable binaries on your Windows system from the official download the page of the Python. &hellip;<br />
Step 2: Run the Python executable installer. &hellip;<br />
Step 3: Install pip on Windows 10/8/7. &hellip;<br />
Step 4: Install Numpy in Python using pip on Windows 10/8/7.</p>

<p>Installation Process of Numpy..</p>

<p>step1: Open the terminal</p>

<p>step2: type pip install numpy</p>

<h2>6) How to import numpy in python?</h2>

<p>Ans: import numpy as np</p>

<h2>7) how to create 1D Array ?</h2>

<p>Ans: num=[1,2,3]<br />
num = np.array(num)<br />
print(&ldquo;1d array : &ldquo;,num)</p>

<h2>8) How to create 2D Array ?</h2>

<p>Ans: num2=[[1,2,3],[4,5,6]]<br />
num2 = np.array(num2)<br />
print(&ldquo;\n2d array : &ldquo;,num2)</p>

<h2>9) How to create 3D Array or ND Array ?</h2>

<p>Ans: num3=[[[1,2,3],[4,5,6],[7,8,9]]]<br />
num3 = np.array(num3)<br />
print(&ldquo;\n3d array : &ldquo;,num3)</p>

<h2>10) How to use shape for 1D Array ?</h2>

<p>Ans: num=[1,2,3] if not defined<br />
print(&lsquo;\nshpae of 1d &lsquo;,num.shape)</p>

<h2>11) How to use shape for 2D Array ?</h2>

<p>Ans: num2=[[1,2,3],[4,5,6]] if not added<br />
print(&lsquo;\nshpae of 2d &lsquo;,num2.shape)</p>

<h2>12) How to use shape for 3d or Nd Array ?</h2>

<p>Ans: num3=[[[1,2,3],[4,5,6],[7,8,9]]] if not added<br />
print(&lsquo;\nshpae of 3d &lsquo;,num3.shape)</p>

<h2>13) How to identified datatyp for numpy array?</h2>

<p>Ans: print(&lsquo;\n data type num 1 &lsquo;,num.dtype)<br />
print(&lsquo;\n data type num 2 &lsquo;,num2.dtype)<br />
print(&lsquo;\n data type num 3 &lsquo;,num3.dtype)</p>

<h2>14) Print 5 zeros ?</h2>

<p>Ans: arr = np.zeros(5)<br />
print(&lsquo;single arrya&rsquo;,arr)</p>

<h2>15) print zeros with 2 rows and 3 columns ?</h2>

<p>Ans: arr2 = np.zeros((2,3))<br />
print(&lsquo;\nprint 2 rows and 3 cols : &lsquo;,arr2)</p>

<h2>16) use of eye() diagonal values ?</h2>

<p>Ans: arr3 = np.eye(4)<br />
print(&lsquo;\ndiaglonal values : &lsquo;,arr3)</p>

<h2>17) use of diag() square matrix ?</h2>

<p>Ans: arr3 = np.diag([1,2,3,4])<br />
print(&lsquo;\n square matrix&rsquo;,arr3)</p>

<h2>18) Print Range Between 1 To 15 and show 4 integers random numbers</h2>

<p>Ans: rand_arr = np.random.randint(1,15,4)<br />
print(&lsquo;\n random number from 1 to 15 &lsquo;,rand_arr)</p>

<h2>19) Print Range Between 1 To 100 and show 4 integers random numbers</h2>

<p>Ans: rand_arr3 = np.random.randint(1,100,20)<br />
print(&lsquo;\n random number from 1 to 100 &lsquo;,rand_arr3)</p>

<h2>20) Print Range Between random number 2 row and 3 cols integers random numbers</h2>

<p>Ans: rand_arr2 = np.random.randint([2,3])<br />
print(&lsquo;\n random number 2 row and 3 cols &lsquo;,rand_arr2)</p>

<h2>21) I&rsquo;ve Found A Bug. What Do I Do?</h2>

<p>The SciPy development team works hard to make SciPy as reliable as possible, but, as in any software product, bugs do occur. If you find bugs that affect your software, please tell us by entering a ticket in the SciPy bug tracker, or NumPy bug tracker, as appropriate.</p>

<h2>22) How Can I Get Involved In Scipy?</h2>

<p>Drop us a mail on the mailing lists. We are keen for more people to help out writing code, unit tests, documentation (including translations into other languages), and helping out with the website.</p>

<h2>23) Is There Commercial Support Available?</h2>

<p>Yes, commercial support is offered for SciPy by Enthought.</p>

<h2>24) What Is The Difference Between Numpy And Scipy?</h2>

<p>In an ideal world, NumPy would contain nothing but the array data type and the most basic operations: indexing, sorting, reshaping, basic elementwise functions, et cetera. All numerical code would reside in SciPy. However, one of NumPy&rsquo;s important goals is compatibility, so NumPy tries to retain all features supported by either of its predecessors. Thus NumPy contains some linear algebra functions, even though these more properly belong in SciPy. In any case, SciPy contains more fully-featured versions of the linear algebra modules, as well as many other numerical algorithms. If you are doing scientific computing with python, you should probably install both NumPy and SciPy. Most new features belong in SciPy rather than NumPy.</p>

<h2>25) How Do I Make Plots Using Numpy/scipy?</h2>

<p>Plotting functionality is beyond the scope of NumPy and SciPy, which focus on numerical objects and algorithms. Several packages exist that integrate closely with NumPy to produce high quality plots, such as the immensely popular Matplotlib and the extensible, modular toolkit Chaco.</p>

<h2>26) How Do I Make 3d Plots/visualizations Using Numpy/scipy?</h2>

<p>Like 2D plotting, 3D graphics is beyond the scope of NumPy and SciPy, but just as in the 2D case, packages exist that integrate with NumPy. Matplotlib provides basic 3D plotting in the mplot3d subpackage, whereas Mayavi provides a wide range of high-quality 3D visualization features, utilizing the powerful VTK engine.</p>

<h2>27) Why Both Numpy.linalg And Scipy.linalg? What&rsquo;s The Difference?</h2>

<p>One of the design goals of NumPy was to make it buildable without a Fortran compiler, and if you don&rsquo;t have LAPACK available NumPy will use its own implementation. SciPy requires a Fortran compiler to be built, and heavily depends on wrapped Fortran code.</p>

<p>The linalg modules in NumPy and SciPy have some common functions but with different docstrings, and scipy.linalgcontains functions not found in numpy.linalg, such as functions related to LU decomposition and the Schur decomposition, multiple ways of calculating the pseudoinverse, and matrix transcendentals like the matrix logarithm. Some functions that exist in both have augmented functionality in scipy.linalg; for example scipy.linalg.eig() can take a second matrix argument for solving generalized eigenvalue problems.</p>

<h2>28) Do Numpy And Scipy Support Python 3.x?</h2>

<p>NumPy and SciPy support the Python 2.x series, (versions 2.6 and 2.7), as well as Python 3.2 and newer. The first release of NumPy to support Python 3 was NumPy 1.5.0. Python 3 support in SciPy starts with version 0.9.0.</p>

<h2>29) Does Numpy/scipy Work With Jython?</h2>

<p>No. Simply put, Jython runs on top of the Java Virtual Machine and has no way to interface with extensions written in C for the standard Python (CPython) interpreter.</p>

<h2>30) Does Numpy/scipy Work With Ironpython (.net)?</h2>

<p>Some users have reported success in using NumPy with Ironclad on 32-bit Windows. The current status of Ironclad support for SciPy is unknown, but there are several complicating factors (namely the Fortran compiler situation on Windows) that make it less feasible than NumPy.</p>

<h2>31) What Is The Preferred Way To Check For An Empty (zero Element) Array?</h2>

<p>If you are certain a variable is an array, then use the size attribute. If the variable may be a list or other sequence type, use len().</p>

<p>The size attribute is preferable to len because:</p>

<blockquote>
<p>a = numpy.zeros((1,0))<br />
a.size<br />
0<br />
whereas<br />
len(a)<br />
1</p>
</blockquote>

<h2>32) I Want To Load Data From A Text File. How Do I Make This Code More Efficient?</h2>

<p>Use numpy.loadtxt(). Even if your text file has header and footer lines or comments, loadtxt can almost certainly read it; it is convenient and efficient.</p>

<p>If you find this still too slow, you should consider changing to a more efficient file format than plain text. There are a large number of alternatives, depending on your needs (and on which version of NumPy/SciPy you are using):</p>

<p>Text files: slow, huge, portable, human-readable; built into</p>

<p>NumPy Raw binary: no metadata, totally unportable, fast; built into</p>

<p>NumPy pickle: somewhat slow, somewhat portable (may be incompatible with different NumPy versions); built into NumPy</p>

<p>MATLAB format: portable; built into SciPy (scipy.io.loadmat())</p>

<p>HDF5: high-powered kitchen-sink format; both PyTables and h5py provide a NumPy friendly interface on top of the core HDF5 library written in C.</p>

<p>FITS: standard kitchen-sink format in astronomy; the astropy library provides a convenient Python interface through its io.fits package. .npy: NumPy native binary data format, simple, efficient, portable; built into NumPy as of 1.0.5.</p>

<h2>33) Why Not Just Have A Separate Operator For Matrix Multiplication?</h2>

<p>From Python 3.5, the @ symbol will be defined as a matrix multiplication operator, and Numpy and Scipy will make use of this. This addition was the subject of PEP 465. The separate matrix and array types exist to work around the lack of this operator in earlier versions of Python.</p>

<h2>34) How Do I Find The Indices Of An Array Where Some Condition Is True?</h2>

<p>Answer :The prefered idiom for doing this is to use the function numpy.nonzero() , or the nonzero() method of an array. Given an array a, the condition a &gt; 3 returns a boolean array and since False is interpreted as 0 in Python and NumPy, np.nonzero(a &gt; 3)yields the indices of a where the condition is true.</p>

<blockquote>
<p>import numpy as np<br />
a = np.array([[1,2,3],[4,5,6],[7,8,9]])<br />
a &gt; 3<br />
array([[False, False, False],<br />
[ True, True, True],<br />
[ True, True, True]], dtype=bool)<br />
np.nonzero(a &gt; 3)<br />
(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))<br />
The nonzero() method of the boolean array can also be called.<br />
(a &gt; 3).nonzero()<br />
(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</p>
</blockquote>

<h2>35) How Do I Count The Number Of Times Each Value Appears In An Array Of Integers?</h2>

<p>Use numpy.bincount(). The resulting array is</p>

<blockquote>
<p>arr = numpy.array([0, 5, 4, 0, 4, 4, 3, 0, 0, 5, 2, 1, 1, 9])<br />
numpy.bincount(arr)</p>
</blockquote>

<p>The argument to bincount() must consist of positive integers or booleans. Negative integers are not supported.</p>

<h2>36) List the advantages NumPy Arrays have over (nested) Python lists?</h2>

<p>Python&rsquo;s lists, even though hugely efficient containers capable of a number of functions, have several limitations when compared to NumPy arrays. It is not possible to perform vectorised operations which includes element-wise addition and multiplication.</p>

<p>They also require that Python store the type information of every element since they support objects of different types. This means a type dispatching code must be executed each time an operation on an element is done. Also, each iteration would have to undergo type checks and require Python API bookkeeping resulting in very few operations being carried by C loops.</p>

<h2>37) List the steps to create a 1D array and 2D array</h2>

<p>A one-dimensional array is created as follows:</p>

<p>num=[1,2,3]</p>

<p>num = np.array(num)</p>

<p>print(&ldquo;1d array : &ldquo;,num)</p>

<p>A two-dimensional array is created as follows:</p>

<p>num2=[[1,2,3],[4,5,6]]</p>

<p>num2 = np.array(num2)</p>

<p>print(&ldquo;\n2d array : &ldquo;,num2)</p>

<h2>38) How do you create a 3D array?</h2>

<p>A three-dimensional array is created as follows:</p>

<p>num3=[[[1,2,3],[4,5,6],[7,8,9]]]</p>

<p>num3 = np.array(num3)</p>

<p>print(&ldquo;\n3d array : &ldquo;,num3)</p>

<h2>39) What are the steps to use shape for a 1D array, 2D array and 3D/ND array respectively?</h2>

<p>1D Array:</p>

<p>num=[1,2,3] if not added</p>

<p>print(&lsquo;\nshpae of 1d &lsquo;,num.shape)</p>

<p>2D Array:</p>

<p>num2=[[1,2,3],[4,5,6]] if not added</p>

<p>print(&lsquo;\nshpae of 2d &lsquo;,num2.shape)</p>

<p>3D or ND Array:</p>

<p>num3=[[[1,2,3],[4,5,6],[7,8,9]]] if not added</p>

<p>print(&lsquo;\nshpae of 3d &lsquo;,num3.shape)</p>

<h2>40) How can you identify the datatype of a given NumPy array?</h2>

<p>Use the following sequence of codes to identify the datatype of a NumPy array.</p>

<p>print(&lsquo;\n data type num 1 &lsquo;,num.dtype)</p>

<p>print(&lsquo;\n data type num 2 &lsquo;,num2.dtype)</p>

<p>print(&lsquo;\n data type num 3 &lsquo;,num3.dtype)</p>

<h2>41) What is the procedure to count the number of times a given value appears in an array of integers?</h2>

<p>You can count the number of the times a given value appears using the bincount() function. It should be noted that the bincount() function accepts positive integers or boolean expressions as its argument. Negative integers cannot be used.</p>

<p>Use NumPy.bincount(). The resulting array is</p>

<blockquote>
<p>arr = NumPy.array([0, 5, 4, 0, 4, 4, 3, 0, 0, 5, 2, 1, 1, 9])</p>

<p>NumPy.bincount(arr)</p>
</blockquote>

<h2>42) What is the procedure to find the indices of an array on NumPy where some condition is true?</h2>

<p>You may use the function numpy.nonzero() to find the indices or an array. You can also use the nonzero() method to do so.</p>

<p>In the following program, we will take an array a, where the condition is a &gt; 3. It returns a boolean array. We know False on Python and NumPy is denoted as 0. Therefore, np.nonzero(a &gt; 3) will return the indices of the array a where the condition is True.</p>

<blockquote>
<p>import numpy as np</p>

<p>a = np.array([[1,2,3],[4,5,6],[7,8,9]])</p>

<p>a &gt; 3</p>
</blockquote>

<p>array([[False, False, False],</p>

<p>[ True, True, True],</p>

<p>[ True, True, True]], dtype=bool)</p>

<blockquote>
<p>np.nonzero(a &gt; 3)</p>
</blockquote>

<p>(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</p>

<p>You can also call the nonzero() method of the boolean array.</p>

<blockquote>
<p>(a &gt; 3).nonzero()</p>
</blockquote>

<p>(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</p>

<h2>43) Shown below is the input NumPy array. Delete column two and replace it with the new column given below.</h2>

<p>import NumPy</p>

<p>sampleArray = NumPy.array([[34,43,73],[82,22,12],[53,94,66]])</p>

<p>newColumn = NumPy.array([[10,10,10]])</p>

<p>Expected Output:</p>

<p>Printing Original array</p>

<p>[[34 43 73]</p>

<p>[82 22 12]</p>

<p>[53 94 66]]</p>

<p>Array after deleting column 2 on axis 1</p>

<p>[[34 73]</p>

<p>[82 12]</p>

<p>[53 66]]</p>

<p>Array after inserting column 2 on axis 1</p>

<p>[[34 10 73]</p>

<p>[82 10 12]</p>

<p>[53 10 66]]</p>

<p>Solution:</p>

<p>import NumPy</p>

<p>print(&ldquo;Printing Original array&rdquo;)</p>

<p>sampleArray = NumPy.array([[34,43,73],[82,22,12],[53,94,66]])</p>

<p>print (sampleArray)</p>

<p>print(&ldquo;Array after deleting column 2 on axis 1&rdquo;)</p>

<p>sampleArray = NumPy.delete(sampleArray , 1, axis = 1)</p>

<p>print (sampleArray)</p>

<p>arr = NumPy.array([[10,10,10]])</p>

<p>print(&ldquo;Array after inserting column 2 on axis 1&rdquo;)</p>

<p>sampleArray = NumPy.insert(sampleArray , 1, arr, axis = 1)</p>

<p>print (sampleArray)</p>

<h2>44) Create a two 2-D array. Plot it using matplotlib</h2>

<p>Solution:</p>

<p>import NumPy</p>

<p>print(&ldquo;Printing Original array&rdquo;)</p>

<p>sampleArray = NumPy.array([[34,43,73],[82,22,12],[53,94,66]])</p>

<p>print (sampleArray)</p>

<p>print(&ldquo;Array after deleting column 2 on axis 1&rdquo;)</p>

<p>sampleArray = NumPy.delete(sampleArray , 1, axis = 1)</p>

<p>print (sampleArray)</p>

<p>arr = NumPy.array([[10,10,10]])</p>

<p>print(&ldquo;Array after inserting column 2 on axis 1&rdquo;)</p>

<p>sampleArray = NumPy.insert(sampleArray , 1, arr, axis = 1)</p>

<p>print (sampleArray)</p>

<h2>45) Why NumPy is faster than list?</h2>

<p>NumPy Arrays are faster than Python Lists because of the following reasons: An array is a collection of homogeneous data-types that are stored in contiguous memory locations. On the other hand, a list in Python is a collection of heterogeneous data types stored in non-contiguous memory locations</p>

<h2>46) What is the main use of NumPy?</h2>

<p>NumPy can be used to perform a wide variety of mathematical operations on arrays. It adds powerful data structures to Python that guarantee efficient calculations with arrays and matrices and it supplies an enormous library of high-level mathematical functions that operate on these arrays and matrices.</p>

<h2>47) Does NumPy use multiple cores?</h2>

<p>I know that numpy is configured for multiple cores, since I can see tests using numpy. dot use all my cores, so I just reimplemented mean as a dot product, and it runs way faster.</p>

<h2>48) What is difference between NumPy and Pandas?</h2>

<p>Difference between Pandas and NumPy: &hellip; NumPy library provides objects for multi-dimensional arrays, whereas Pandas is capable of offering an in-memory 2d table object called DataFrame. NumPy consumes less memory as compared to Pandas. Indexing of the Series objects is quite slow as compared to NumPy arrays.</p>

<h2>49) Can you import libraries in coding interviews?</h2>

<p>During a coding interview, you can always ask if you can use such-and-such a function from the library, but generally you can as long as that doesn&rsquo;t save you from actually having to solve the problem. If you&rsquo;re asked to implement a sort, for example, you shouldn&rsquo;t do it by calling the library sort.</p>

<h2>50) Does NumPy use SIMD?</h2>

<p>NumPy comes with a flexible working mechanism that allows it to harness the SIMD features that CPUs own, in order to provide faster and more stable performance on all popular platforms.</p>

<p>&nbsp;</p>

<h3>Conclusion</h3>

<p>The popularity of the NumPy package has grown immensely among the data science and python developers community ever since it was first introduced in 2005 due to the wide range of high-performing functionalities it offers. This is why it becomes essential to learn and be prepared for the interview questions about this package. In this article, we have seen the most commonly asked NumPy interview questions for freshers and experienced people, along with some questions on writing python programs which make use of NumPy functions.</p>

<p>&nbsp;</p>
